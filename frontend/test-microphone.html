<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éº¦å…‹é£æµ‹è¯•</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        #volumeMeter {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
        }
        #volumeBar {
            height: 100%;
            background: linear-gradient(to right, #4caf50, #ffeb3b, #f44336);
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <h1>ğŸ¤ éº¦å…‹é£ä¸ Socket.IO æµ‹è¯•</h1>

    <div class="section">
        <h2>1. Socket.IO è¿æ¥æµ‹è¯•</h2>
        <button onclick="testSocketConnect()">è¿æ¥åˆ°åç«¯</button>
        <button onclick="testSocketDisconnect()">æ–­å¼€è¿æ¥</button>
        <div id="socketStatus" class="status info">æœªè¿æ¥</div>
    </div>

    <div class="section">
        <h2>2. éº¦å…‹é£æƒé™æµ‹è¯•</h2>
        <button onclick="testMicrophone()">æµ‹è¯•éº¦å…‹é£</button>
        <div id="micStatus" class="status info">æœªæµ‹è¯•</div>
    </div>

    <div class="section">
        <h2>3. éŸ³é‡ç›‘æ§</h2>
        <div id="volumeMeter">
            <div id="volumeBar"></div>
        </div>
        <p id="volumeText">éŸ³é‡: 0%</p>
    </div>

    <div class="section">
        <h2>4. å‘é€éŸ³é¢‘åˆ°åç«¯</h2>
        <button onclick="startSending()">å¼€å§‹å‘é€</button>
        <button onclick="stopSending()">åœæ­¢å‘é€</button>
        <div id="sendStatus" class="status info">æœªå‘é€</div>
        <p>å·²å‘é€å—æ•°: <span id="chunkCount">0</span></p>
    </div>

    <div class="section">
        <h2>5. æ§åˆ¶å°æ—¥å¿—</h2>
        <div id="logs" style="max-height: 200px; overflow-y: auto; background: #f5f5f5; padding: 10px; font-family: monospace; font-size: 12px;"></div>
    </div>

    <script>
        let socket = null;
        let audioContext = null;
        let analyser = null;
        let mediaStream = null;
        let processor = null;
        let isSending = false;
        let chunkCount = 0;

        function log(message, type = 'info') {
            const logs = document.getElementById('logs');
            const time = new Date().toLocaleTimeString();
            const color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'black';
            logs.innerHTML = `<div style="color: ${color}">[${time}] ${message}</div>` + logs.innerHTML;
        }

        function updateStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.className = `status ${type}`;
            el.textContent = message;
        }

        // Socket.IO æµ‹è¯•
        function testSocketConnect() {
            log('å°è¯•è¿æ¥åˆ°åç«¯...', 'info');
            socket = io('http://localhost:12394', {
                transports: ['websocket', 'polling']
            });

            socket.on('connect', () => {
                log(`âœ… Socket.IO å·²è¿æ¥! ID: ${socket.id}`, 'success');
                updateStatus('socketStatus', `å·²è¿æ¥ (ID: ${socket.id})`, 'success');
            });

            socket.on('disconnect', () => {
                log('âŒ Socket.IO å·²æ–­å¼€', 'error');
                updateStatus('socketStatus', 'å·²æ–­å¼€', 'error');
            });

            socket.on('connect_error', (err) => {
                log(`âŒ è¿æ¥é”™è¯¯: ${err.message}`, 'error');
                updateStatus('socketStatus', `è¿æ¥å¤±è´¥: ${err.message}`, 'error');
            });

            socket.on('control', (data) => {
                log(`ğŸ“¨ æ”¶åˆ°æ§åˆ¶ä¿¡å·: ${JSON.stringify(data)}`, 'info');
            });

            socket.on('text', (data) => {
                log(`ğŸ“¨ æ”¶åˆ°æ–‡æœ¬: ${JSON.stringify(data)}`, 'info');
            });

            socket.on('error', (data) => {
                log(`âŒ æ”¶åˆ°é”™è¯¯: ${JSON.stringify(data)}`, 'error');
            });
        }

        function testSocketDisconnect() {
            if (socket) {
                socket.disconnect();
                log('å·²æ–­å¼€è¿æ¥', 'info');
            }
        }

        // éº¦å…‹é£æµ‹è¯•
        async function testMicrophone() {
            try {
                log('è¯·æ±‚éº¦å…‹é£æƒé™...', 'info');

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                    }
                });

                mediaStream = stream;
                log('âœ… éº¦å…‹é£æƒé™å·²è·å–!', 'success');
                updateStatus('micStatus', 'éº¦å…‹é£å·²æˆæƒ', 'success');

                // è®¾ç½®éŸ³é‡åˆ†æ
                audioContext = new AudioContext({ sampleRate: 16000 });
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;

                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                updateVolume();
                log('âœ… éŸ³é‡ç›‘æ§å·²å¯åŠ¨', 'success');

            } catch (err) {
                log(`âŒ éº¦å…‹é£æµ‹è¯•å¤±è´¥: ${err.message}`, 'error');
                updateStatus('micStatus', `å¤±è´¥: ${err.name}`, 'error');
            }
        }

        function updateVolume() {
            if (!analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const sum = dataArray.reduce((a, b) => a + b, 0);
            const average = sum / dataArray.length;
            const volume = Math.round((average / 255) * 100);

            document.getElementById('volumeBar').style.width = volume + '%';
            document.getElementById('volumeText').textContent = `éŸ³é‡: ${volume}%`;

            requestAnimationFrame(updateVolume);
        }

        // å‘é€éŸ³é¢‘
        async function startSending() {
            if (!socket || !socket.connected) {
                log('âŒ Socket.IO æœªè¿æ¥ï¼Œæ— æ³•å‘é€', 'error');
                return;
            }

            if (!mediaStream) {
                log('âŒ éº¦å…‹é£æœªå¯åŠ¨ï¼Œè¯·å…ˆæµ‹è¯•éº¦å…‹é£', 'error');
                return;
            }

            isSending = true;
            chunkCount = 0;
            updateStatus('sendStatus', 'æ­£åœ¨å‘é€...', 'info');
            log('ğŸ¤ å¼€å§‹å‘é€éŸ³é¢‘æ•°æ®...', 'info');

            // åˆ›å»º ScriptProcessor å¹¶è¿æ¥åˆ°é™éŸ³è¾“å‡º
            const processor = audioContext.createScriptProcessor(4096, 1, 1);
            const source = audioContext.createMediaStreamSource(mediaStream);
            const silentDestination = audioContext.createMediaStreamDestination();

            source.connect(processor);
            processor.connect(silentDestination);  // å¿…é¡»è¿æ¥æ‰èƒ½è§¦å‘ onaudioprocess

            processor.onaudioprocess = (event) => {
                if (!isSending) return;

                const inputData = event.inputBuffer.getChannelData(0);

                // åº”ç”¨ 5 å€å¢ç›Š
                const pcmData = new Int16Array(inputData.length);
                const gain = 5.0;

                for (let i = 0; i < inputData.length; i++) {
                    let s = inputData[i] * gain;
                    s = Math.max(-1, Math.min(1, s));
                    pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }

                // æ¯ 10 ä¸ªå—æ‰“å°æ—¥å¿—
                if (chunkCount % 10 === 1) {
                    const min = Math.min(...Array.from(pcmData));
                    const max = Math.max(...Array.from(pcmData));
                    const mean = pcmData.reduce((sum, v) => sum + Math.abs(v), 0) / pcmData.length;
                    log(`ğŸ“Š å‘é€å— #${chunkCount}: range=[${min.toFixed(0)}, ${max.toFixed(0)}], mean=${mean.toFixed(2)}`, 'info');
                }

                // å‘é€åˆ°åç«¯
                socket.emit('raw_audio_data', {
                    audio: Array.from(pcmData)
                });

                chunkCount++;
                document.getElementById('chunkCount').textContent = chunkCount;
            };

            // ä¿å­˜ processor å¼•ç”¨ä»¥ä¾¿åœæ­¢
            window._processor = processor;
            window._source = source;
        }

        function stopSending() {
            isSending = false;
            updateStatus('sendStatus', 'å·²åœæ­¢', 'info');
            log(`â¹ï¸ å·²åœæ­¢å‘é€ï¼Œå…±å‘é€ ${chunkCount} ä¸ªå—`, 'info');

            // æ¸…ç† processor
            if (window._processor && window._source) {
                window._source.disconnect();
                window._processor.disconnect();
                window._processor = null;
                window._source = null;
            }
        }
    </script>
</body>
</html>
